use crate::ast::*;
use std::str::FromStr;

grammar;

// List of all terminals, and their precedence
// Terminals within the same block have the same precedence except that regexes have lower.
// Terminals in else-blocks have lower precedence than the blocks before.
match {
    "SELECT" => SELECT,
    "FROM" => FROM,
    "WHERE" => WHERE,
    "INSERT" => INSERT,
    "INTO" => INTO,
    "VALUES" => VALUES,
    "DELETE" => DELETE,
    "UPDATE" => UPDATE,
    "JOIN" => JOIN,
    "LEFT" => LEFT,
    "RIGHT" => RIGHT,
    "INNER" => INNER,
    "OUTER" => OUTER,
    "FULL" => FULL,
    "SET" => SET,
    "ON" => ON,
    "AND" => AND,
    "OR" => OR,
    "\"" => QUOTE,
    ",",
    ")",
    "(",
    "=",
    "!=",
    "<=",
    ">=",
    "<",
    ">",
    ";",
    r"[0-9]+" => INTEGER,
    r"[A-z][A-z0-9_]*" => IDENT,
    r#""[^"]*""# => STR,
}

// Main production
pub Stmt: Stmt<'input> = {
    <select:Select> ";" => Stmt::Select(select),
    <insert:Insert> ";" => Stmt::Insert(insert),
    <delete:Delete> ";" => Stmt::Delete(delete),
    <update:Update> ";" => Stmt::Update(update),
}

Delete: Delete<'input> = {
    DELETE FROM <table:IDENT> <where_clause:(WhereClause?)> => Delete {
        table,
        where_clause,
    },
}

Update: Update<'input> = {
    UPDATE
    <table:IDENT> SET
    <ass:Comma<Ass>>
    <where_clause:(WhereClause?)>
    => Update {
        table,
        ass,
        where_clause,
    },
}

Select: Select<'input> = {
    SELECT
        <exprs:Comma<Expr>>
        <from:(FROM <SelectFrom>)?>
        <where_clause:WhereClause?>
    => Select {
        exprs,
        from: from,
        where_clause,
    },
}

SelectFrom: SelectFrom<'input> = {
    <table_a:SelectFrom>
        <join_type:JoinType>
        <table_b:SelectFrom2>
        <on_clause:(ON <Expr>)?>
    => SelectFrom::Join(box Join {
        table_a,
        table_b,
        join_type,
        on_clause,
    }),
    SelectFrom2,
}

SelectFrom2: SelectFrom<'input> = {
    "(" <s:Select> ")" => SelectFrom::Select(box s),
    <id:IDENT> => SelectFrom::Table(id),
    "(" <SelectFrom> ")",
}

WhereClause: WhereClause<'input> = {
    WHERE <condition:Expr> => WhereClause(condition),
}

Insert: Insert<'input> = {
    INSERT INTO <table:IDENT>
        <columns:("(" Comma<IDENT> ")")?>
        <values:InsertValues?>
    => Insert {
        table,
        columns: columns.map(|(_, cols, _)| cols).unwrap_or(vec![]),
        values: values.unwrap_or(vec![]),
    }
}

JoinType: JoinType = {
    LEFT OUTER? JOIN => JoinType::LeftOuter,
    RIGHT OUTER? JOIN => JoinType::RightOuter,
    FULL OUTER? JOIN => JoinType::FullOuter,
    INNER? JOIN => JoinType::Inner,
}

Expr3: Expr<'input> = {
    <id:IDENT> => Expr::Ident(id),
    <int:Integer> => Expr::Integer(int),
    <s:Str> => Expr::Str(s),
    "(" <e:Expr> ")" => e,
}

Expr2: Expr<'input> = {
    <e1:Expr2> "="  <e2:Expr3> => Expr::Equals(box e1, box e2),
    <e1:Expr2> "!=" <e2:Expr3> => Expr::NotEquals(box e1, box e2),
    <e1:Expr2> "<=" <e2:Expr3> => Expr::LessEquals(box e1, box e2),
    <e1:Expr2> ">=" <e2:Expr3> => Expr::GreaterEquals(box e1, box e2),
    <e1:Expr2> "<"  <e2:Expr3> => Expr::LessThan(box e1, box e2),
    <e1:Expr2> ">"  <e2:Expr3> => Expr::GreaterThan(box e1, box e2),
    Expr3,
}

Expr1: Expr<'input> = {
    <e1:Expr1> AND <e2:Expr2> => Expr::And(box e1, box e2),
    Expr2
}

Expr: Expr<'input> = {
    <e1:Expr> OR <e2:Expr1> => Expr::Or(box e1, box e2),
    Expr1,
}

Ass: Ass<'input> = {
    <col:IDENT> "=" <expr:Expr> => Ass {
        col,
        expr,
    }
}

InsertValues: Vec<Expr<'input>> = {
    VALUES "(" <vals:Comma<Expr>> ")" => vals,
}

Str: &'input str = {
    <s:STR> => {
        s.strip_prefix('"').unwrap().strip_suffix('"').unwrap()
    },
}

Integer: i32 = {
    INTEGER => i32::from_str(<>).unwrap()
};

// Generic helper-rule for comma-separated lists
Comma<E>: Vec<E> =
    <v0:(<E> ",")*> <e1:E?> =>
        v0.into_iter().chain(e1).collect();

