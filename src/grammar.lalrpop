use crate::ast::*;
use std::str::FromStr;
use crate::pattern::Pattern;
use crate::types::Value;

grammar;

// List of all terminals, and their precedence
// Terminals within the same block have the same precedence except that regexes have lower.
// Terminals in else-blocks have lower precedence than the blocks before.
match {
    "SELECT" => SELECT,
    "FROM" => FROM,
    "WHERE" => WHERE,
    "INSERT" => INSERT,
    "INTO" => INTO,
    "VALUES" => VALUES,
    "DELETE" => DELETE,
    "UPDATE" => UPDATE,
    "JOIN" => JOIN,
    "LEFT" => LEFT,
    "RIGHT" => RIGHT,
    "INNER" => INNER,
    "OUTER" => OUTER,
    "FULL" => FULL,
    "SET" => SET,
    "ON" => ON,
    "AND" => AND,
    "OR" => OR,
    "\"" => QUOTE,
    "_",
    ",",
    ")",
    "(",
    "=",
    "!=",
    "<=",
    ">=",
    "<",
    ">",
    ";",
    ":",
    "true",
    "false",
    r"-?[0-9]+" => INTEGER,
    // TODO: make sure this regex for floats conform to standards
    r"-?[0-9]+(\.[0-9]+)([eE]-?[0-9]+)?" => FLOAT,
    r"[A-z][A-z0-9_]*" => IDENT,
    r#""[^"]*""# => STR,
}

// Main production
pub Stmt: Stmt<'input> = {
    <Select> ";" => Stmt::Select(<>),
    <Insert> ";" => Stmt::Insert(<>),
    <Delete> ";" => Stmt::Delete(<>),
    <Update> ";" => Stmt::Update(<>),
}

Delete: Delete<'input> = {
    DELETE FROM <table:IDENT> <where_clause:(WhereClause?)> => Delete {
        table,
        where_clause,
    },
}

Update: Update<'input> = {
    UPDATE
    <table:IDENT> SET
    <ass:Comma<Ass>>
    <where_clause:(WhereClause?)>
    => Update {
        table,
        ass,
        where_clause,
    },
}

Select: Select<'input> = {
    SELECT
        <items:Comma<SelectItem>>
        <from:(FROM <SelectFrom>)?>
        <where_clause:WhereClause?>
    => Select {
        items,
        from: from,
        where_clause,
    },
}

SelectItem: SelectItem<'input> = {
    <col:IDENT> ":" <pattern:Pattern> => (SelectItem::Pattern(col, pattern)),
    Expr => SelectItem::Expr(<>),
}

SelectFrom: SelectFrom<'input> = {
    <table_a:SelectFrom>
        <join_type:JoinType>
        <table_b:SelectFrom2>
        <on_clause:(ON <Expr>)?>
    => SelectFrom::Join(box Join {
        table_a,
        table_b,
        join_type,
        on_clause,
    }),
    SelectFrom2,
}

SelectFrom2: SelectFrom<'input> = {
    "(" <Select> ")" => SelectFrom::Select(box <>),
    IDENT => SelectFrom::Table(<>),
    "(" <SelectFrom> ")",
}

WhereClause: WhereClause<'input> = {
    WHERE <Expr> => WhereClause(<>),
}

Insert: Insert<'input> = {
    INSERT INTO <table:IDENT>
        <columns:("(" Comma<IDENT> ")")?>
        <values:InsertValues?>
    => Insert {
        table,
        columns: columns.map(|(_, cols, _)| cols).unwrap_or(vec![]),
        values: values.unwrap_or(vec![]),
    }
}

JoinType: JoinType = {
    LEFT OUTER? JOIN => JoinType::LeftOuter,
    RIGHT OUTER? JOIN => JoinType::RightOuter,
    FULL OUTER? JOIN => JoinType::FullOuter,
    INNER? JOIN => JoinType::Inner,
}

Value: Value = {
    Integer => Value::Integer(<>),
    Double => Value::Double(<>),
    Bool => Value::Bool(<>),
    Str => unimplemented!("Strings aren't supported"),
    // TODO: This grammar will probably conflict with function calls...
    <variant:IDENT> "(" <values:Comma<Value>> ")" => Value::Sum(variant.to_string(), values),
}

Expr3: Expr<'input> = {
    IDENT => Expr::Ident(<>),
    Value => Expr::Value(<>),
    "(" <Expr> ")",
}

Expr2: Expr<'input> = {
    <e1:Expr2> "="  <e2:Expr3> => Expr::Equals(box e1, box e2),
    <e1:Expr2> "!=" <e2:Expr3> => Expr::NotEquals(box e1, box e2),
    <e1:Expr2> "<=" <e2:Expr3> => Expr::LessEquals(box e1, box e2),
    <e1:Expr2> ">=" <e2:Expr3> => Expr::GreaterEquals(box e1, box e2),
    <e1:Expr2> "<"  <e2:Expr3> => Expr::LessThan(box e1, box e2),
    <e1:Expr2> ">"  <e2:Expr3> => Expr::GreaterThan(box e1, box e2),
    Expr3,
}

Expr1: Expr<'input> = {
    <e1:Expr1> AND <e2:Expr2> => Expr::And(box e1, box e2),
    Expr2
}

Expr: Expr<'input> = {
    <e1:Expr> OR <e2:Expr1> => Expr::Or(box e1, box e2),
    Expr1,
}

Ass: Ass<'input> = {
    <col:IDENT> "=" <expr:Expr> => Ass {
        col,
        expr,
    }
}

InsertValues: Vec<Expr<'input>> = {
    VALUES "(" <Comma<Expr>> ")",
}

pub Pattern: Pattern<'input> = {
    "_" => Pattern::Ignore,
    Integer => Pattern::Int(<>),
    Bool => Pattern::Bool(<>),
    Double => Pattern::Double(<>),
    IDENT => Pattern::Binding(<>),
    <id:IDENT> "(" <ps:Comma<Pattern>> ")" => Pattern::Variant(id, ps),
}

Str: &'input str = {
    STR => <>.strip_prefix('"').unwrap().strip_suffix('"').unwrap(),
}

Integer: i32 = {
    INTEGER => i32::from_str(<>).unwrap()
};

Double: f64 = {
    FLOAT => f64::from_str(<>).unwrap()
}

Bool: bool = {
    "true" => true,
    "false" => true,
};

// Generic helper-rule for comma-separated lists
Comma<E>: Vec<E> =
    <v0:(<E> ",")*> <e1:E?> =>
        v0.into_iter().chain(e1).collect();

