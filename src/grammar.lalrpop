use std::str::FromStr;
use crate::ast::{Stmt, Select, SelectFrom,  Expr};

grammar;

// List of all terminals, and their prescedence
// Terminals within the same block have the same prescedence except that regexes have lower.
// Terminals in else-blocks have lower prescedence than the blocks before.
match {
    "SELECT" => SELECT,
    "FROM" => FROM,
    "INSERT" => INSERT,
    "INTO" => INTO,
    "VALUES" => VALUES,
    "\"" => QUOTE,
    ";" => SEMICOLON,
    "+" => PLUS,
    "-" => MINUS,
    "*" => STAR,
    "/" => SLASH,
    "," => COMMA,
    ")" => RPAREN,
    "(" => LPAREN,
} else {
    r"[0-9]+" => INTEGER,
    r"[A-z_]+" => IDENTIFIER,
    r#""[^"]*""# => STR,
}

// Main production
pub Stmt: Stmt<'input> = {
    <select:Select> SEMICOLON => Stmt::Select(select), 
    INSERT INTO <table:Ident>
        <columns:(LPAREN Comma<Ident> RPAREN)?>
        <values:InsertValues?>
        SEMICOLON
    => {
        Stmt::Insert {
            into: table,
            columns: columns.map(|(_, cols, _)| cols).unwrap_or(vec![]),
            values: values.unwrap_or(vec![]),
        }
    },
}

Select: Select<'input> = {
    SELECT
        <exprs:Comma<Expr>>
        <from:(SelectFrom?)>
    => Select {
        exprs,
        from,
    },
}

SelectFrom: SelectFrom<'input> =Â {
    FROM <id:Ident> => SelectFrom::Table(id),
    FROM LPAREN <s:Select> RPAREN => SelectFrom::Select(Box::new(s)),
}

Expr: Expr<'input> = {
    <id:Ident> => Expr::Ident(id),
    <int:Integer> => Expr::Integer(int),
    <s:Str> => Expr::Str(s),
}

Ident: &'input str = {
    IDENTIFIER => <>
}

InsertValues: Vec<Expr<'input>> = {
    VALUES LPAREN <vals:Comma<Expr>> RPAREN => vals,
}

Str: &'input str = {
    <s:STR> => {
        s.strip_prefix('"').unwrap().strip_suffix('"').unwrap()
    },
}

Integer: i32 = {
    INTEGER => i32::from_str(<>).unwrap()
};

// Generic helper-rule for comma-separated lists
Comma<E>: Vec<E> =
    <v0:(<E> COMMA)*> <e1:E?> =>
        v0.into_iter().chain(e1).collect();

